package slick.compiler

import slick.ast._
import Util._
import TypeUtil._

/** Rewrite zip joins into a form suitable for SQL (using inner joins and
  * RowNumber columns.
  * We rely on having a Bind around every Join and both of its generators,
  * which should have been generated by Phase.forceOuterBinds. The inner
  * Binds need to select Pure(StructNode(...)) which should be the outcome
  * of Phase.flattenProjections. */
class ResolveZipJoins extends Phase {
  type State = Boolean
  val name = "resolveZipJoins"

  def apply(state: CompilerState) = {
    val n2 = resolveZipJoins(state.tree)
    state + (this -> (n2 ne state.tree)) withNode n2
  }

  def resolveZipJoins(n: Node): Node = n.replaceInvalidate {
    // zip with index
    case (b @ Bind(oldBindSym, Join(_, _,
        l @ Bind(lsym, lfrom, Pure(StructNode(lstruct), _)),
        RangeFrom(offset),
        JoinType.Zip, LiteralNode(true)), Pure(sel, ts)), invalid, _) =>
      logger.debug("Resolving zipWithIndex:", b)
      val idxSym = new AnonSymbol
      val idxExpr =
        if(offset == 1L) RowNumber()
        else Library.-.typed[Long](RowNumber(), LiteralNode(1L - offset))
      val innerBind :@ CollectionType(_, el) = Bind(lsym, lfrom, Pure(StructNode(lstruct :+ (idxSym, idxExpr)))).infer()
      val bindSym = new AnonSymbol
      val OldBindRef = Ref(oldBindSym)
      val bindRef = Ref(bindSym) :@ el
      val newOuterSel = sel.replace {
        case Select(OldBindRef, ElementSymbol(1)) => bindRef
        case Select(OldBindRef, ElementSymbol(2)) => Select(bindRef, idxSym).infer()
      }
      val b2 = Bind(bindSym, innerBind, Pure(newOuterSel)).infer(retype = true)
      logger.debug("Resolved zipWithIndex:", b2)
      (b2, invalid + ts)

    // zip with another query
    case (b @ Bind(s1, Join(jlsym, jrsym,
        l @ Bind(lsym, lfrom, Pure(StructNode(lstruct), ts1)),
        r @ Bind(rsym, rfrom, Pure(StructNode(rstruct), ts2)),
        JoinType.Zip, LiteralNode(true)), _), invalid, _) =>
      logger.debug("Resolving zip:", b)
      val lIdxSym, rIdxSym = new AnonSymbol
      val lInnerBind = Bind(lsym, lfrom, Pure(StructNode(lstruct :+ (lIdxSym, RowNumber())), ts1)).infer(retype = true)
      val rInnerBind = Bind(rsym, rfrom, Pure(StructNode(rstruct :+ (rIdxSym, RowNumber())), ts2)).infer(retype = true)
      val jlRef = Ref(jlsym) :@ lInnerBind.nodeType.asCollectionType.elementType
      val jrRef = Ref(jrsym) :@ rInnerBind.nodeType.asCollectionType.elementType
      val join = Join(jlsym, jrsym, lInnerBind, rInnerBind, JoinType.Inner,
        Library.==.typed[Boolean](Select(jlRef, lIdxSym).infer(), Select(jrRef, rIdxSym).infer())
      )
      val b2 = b.copy(from = join, select = b.select.replace {
        case r @ Ref(s) if s == s1 => r.untyped
      })
      logger.debug("Resolved zip:", b2)
      (b2, invalid)
  }.infer()
}

package scala.slick.lifted

import scala.language.implicitConversions
import scala.slick.ast._

sealed abstract class Projection[T <: Product](children: Column[_]*) extends ColumnBase[T] with ProductNode /*with Product*/ {
  type V = T
  lazy val nodeChildren = children.map(Node(_)).toIndexedSeq

  def <>[R](f: (T => R), g: (R => Option[T])) = MappedProjection[R, T](this, f, g.andThen(_.get))(this)

  override def toString = "Projection" + children.size

  lazy val tpe = ProductType(children.map(_.tpe).toIndexedSeq)
}

final case class MappedProjection[T, P <: Product](child: Node, f: (P => T), g: (T => P))(proj: Projection[P]) extends ColumnBase[T] with NodeGenerator {
  type Self = MappedProjection[_, _]
  override def toString = "MappedProjection"
  private lazy val typeMapping = TypeMapping(Node(child), proj.tpe, (v => g(v.asInstanceOf[T])), (v => f(v.asInstanceOf[P])))
  override def nodeDelegate = if(op eq null) typeMapping else op.nodeDelegate

  protected[this] def nodeRebuild(child: Node): Self = copy[T, P](child = child)(proj)

  override def hashCode() = child.hashCode() + f.hashCode() + g.hashCode()
  override def equals(o: Any) = o match {
    case m: MappedProjection[_,_] => child == m.child && f == m.f && g == m.g
    case _ => false
  }
  def tpe = typeMapping.tpe
}

<#list 2..22 as i>
final class Projection${i}[<#list 1..i as j>T${j}<#if i != j>,</#if></#list>](<#list 1..i as j>__${j}: Column[T${j}]<#if i != j>, </#if></#list>) extends Projection[(<#list 1..i as j>T${j}<#if i != j>,</#if></#list>)](<#list 1..i as j>__${j}<#if i != j>,</#if></#list>) {
  override def mapOp(f: (Node, List[Int]) => Node, positions: List[Int]): this.type = new Projection${i}(
<#list 1..i as j>
    __${j}.mapOp(f, ${j} :: positions)<#if i != j>,</#if>
</#list>  ).asInstanceOf[this.type]
  def <>[R](f: ((<#list 1..i as j>T${j}<#if i != j>,</#if></#list>) => R), g: (R => Option[V])): MappedProjection[R,V] =
    <>(t => f(<#list 1..i as j>t._${j}<#if i != j>,</#if></#list>), g)
}

</#list>

trait LiftTuples {
<#list 2..22 as i>
  implicit def tuple${i}ofColumnToProjection${i}[<#list 1..i as j>T${j}<#if i != j>,</#if></#list>](t: (<#list 1..i as j>Column[T${j}]<#if i != j>,</#if></#list>)): Projection${i}[<#list 1..i as j>T${j}<#if i != j>,</#if></#list>] =
    new Projection${i}[<#list 1..i as j>T${j}<#if i != j>,</#if></#list>](<#list 1..i as j>t._${j}<#if i != j>,</#if></#list>)
</#list>
}

/** Extension methods for prepending and appending values to tuples */
object TupleMethods {
  implicit class ColumnTupleExtensionMethods[T](val c: Column[T]) extends AnyVal {
    def ~ [U](c2: Column[U]): (Column[T], Column[U]) = (c, c2)
    def ~: [U](c2: Column[U]): (Column[U], Column[T]) = (c2, c)
  }
<#list 2..21 as i>
  implicit class Tuple${i}ExtensionMethods[<#list 1..i as j>T${j}<#if i != j>, </#if></#list>](val t: (<#list 1..i as j>Column[T${j}]<#if i != j>, </#if></#list>)) extends AnyVal {
    def ~ [U](c: Column[U]): (<#list 1..i as j>Column[T${j}], </#list>Column[U]) = (<#list 1..i as j>t._${j}, </#list>c)
    def ~: [U](c: Column[U]): (Column[U]<#list 1..i as j>, Column[T${j}]</#list>) = (c<#list 1..i as j>, t._${j}</#list>)
  }
</#list>

  /* A chained extractor for tuples */
  object ~ {
    def unapply[T1 <: Column[_], T2 <: Column[_]](p: (T1,T2)) =
      Some(p)
<#list 3..22 as i>
    def unapply[<#list 1..i as j>T${j} <: Column[_]<#if i != j>,</#if></#list>](p: (<#list 1..i as j>T${j}<#if i != j>,</#if></#list>)) =
      Some((<#list 1..i-1 as j>p._${j}<#if i-1 != j>,</#if></#list>), p._${i})
</#list>
  }
}

trait TupleMethods {
  implicit def ColumnTupleExtensionMethods[T](c: Column[T]) = TupleMethods.ColumnTupleExtensionMethods[T](c)
<#list 2..21 as i>
  implicit def Tuple${i}ExtensionMethods[<#list 1..i as j>T${j}<#if i != j>, </#if></#list>](t: (<#list 1..i as j>Column[T${j}]<#if i != j>, </#if></#list>)) = TupleMethods.Tuple${i}ExtensionMethods[<#list 1..i as j>T${j}<#if i != j>, </#if></#list>](t)
</#list>
  val ~ = TupleMethods.~
}

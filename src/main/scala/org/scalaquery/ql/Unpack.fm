package org.scalaquery.ql

import scala.annotation.implicitNotFound
import org.scalaquery.ast.WithOp
import org.scalaquery.util.{ValueLinearizer, ProductLinearizer}

/**
 * A type class that encodes the unpacking `Mixed => Unpacked` of a
 * `Query[Mixed]` to its result element type `Unpacked` and the packing to a
 * fully packed type `Packed`, i.e. a type where everything which is not a
 * transparent container is wrapped in a `Column[_]`.
 *
 * =Example:=
 * - Mixed: (Column[Int], Column[(Int, String)], (Int, Option[Double]))
 * - Unpacked: (Int, (Int, String), (Int, Option[Double]))
 * - Packed: (Column[Int], Column[(Int, String)], (Column[Int], Column[Option[Double]]))
 * - Linearized: (Int, Int, String, Int, Option[Double])
 */
@implicitNotFound(msg = "Don't know how to unpack ${r"${Mixed_}"} to ${r"${Unpacked_}"} and pack to ${r"${Packed_}"}")
abstract class Packing[-Mixed_, Unpacked_, Packed_] {
  type Mixed = Mixed_
  type Unpacked = Unpacked_
  type Packed = Packed_
  def pack(from: Mixed): Packed
  def packedPacking: Packing[Packed, Unpacked, Packed]
  def linearizer(from: Mixed): ValueLinearizer[_]
}

object Packing extends PackingLowPriority {
  @inline
  def unpackTable[T <: AbstractTable[_]]: Packing[T, Nothing, T] =
    tablePacking.asInstanceOf[Packing[T, Nothing, T]]

  @inline
  implicit def unpackColumn[T]: Packing[Column[T], T, Column[T]] =
    selfLinearizingPacking.asInstanceOf[Packing[Column[T], T, Column[T]]]

  val selfLinearizingPacking: Packing[ValueLinearizer[_], Any, ValueLinearizer[_]] = new IdentityPacking[ValueLinearizer[_], Any] {
    def linearizer(from: Mixed) = from
  }

  val tablePacking: Packing[AbstractTable[_], Any, AbstractTable[_]] = new IdentityPacking[AbstractTable[_], Any] {
    def linearizer(from: Mixed) = from.*
  }
}

abstract class IdentityPacking[Packed, Unpacked] extends Packing[Packed, Unpacked, Packed] {
  def pack(from: Mixed): Packed = from
  def packedPacking: Packing[Packed, Unpacked, Packed] = this
}

class PackingLowPriority extends PackingLowPriority2 {
  @inline
  implicit final def unpackColumnBase[T, C <: ColumnBase[_]](implicit ev: C <:< ColumnBase[T]): Packing[C, T, C] =
    Packing.selfLinearizingPacking.asInstanceOf[Packing[C, T, C]]

  implicit final def unpackPrimitive[T](implicit tm: TypeMapper[T]): Packing[T, T, ConstColumn[T]] = new Packing[T, T, ConstColumn[T]] {
    def pack(from: Mixed) = ConstColumn(from)
    def packedPacking: Packing[Packed, Unpacked, Packed] = unpackColumnBase[T, ConstColumn[T]]
    def linearizer(from: Mixed) = ConstColumn(from)
  }
}

class PackingLowPriority2 {
<#list 2..22 as i>
  implicit final def unpackTuple${i}[<#list 1..i as j>M${j}<#if i != j>,</#if></#list>, <#list 1..i as j>U${j}<#if i != j>,</#if></#list>, <#list 1..i as j>P${j}<#if i != j>,</#if></#list>](implicit <#list 1..i as j>u${j}: Packing[M${j}, U${j}, P${j}]<#if i != j>, </#if></#list>): Packing[(<#list 1..i as j>M${j}<#if i != j>,</#if></#list>), (<#list 1..i as j>U${j}<#if i != j>,</#if></#list>), (<#list 1..i as j>P${j}<#if i != j>,</#if></#list>)] = new Packing[(<#list 1..i as j>M${j}<#if i != j>,</#if></#list>), (<#list 1..i as j>U${j}<#if i != j>,</#if></#list>), (<#list 1..i as j>P${j}<#if i != j>,</#if></#list>)] {
    def pack(from: Mixed) =
      (<#list 1..i as j>u${j}.pack(from._${j})<#if i != j>, </#if></#list>)
    def packedPacking: Packing[Packed, Unpacked, Packed] =
      unpackTuple${i}(<#list 1..i as j>u${j}.packedPacking<#if i != j>, </#if></#list>)
    def linearizer(from: Mixed) =
      new ProductLinearizer(Vector(<#list 1..i as j>u${j}.linearizer(from._${j})<#if i != j>, </#if></#list>))
  }
</#list>
}

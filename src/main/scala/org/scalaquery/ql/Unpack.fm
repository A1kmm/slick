package org.scalaquery.ql

import scala.annotation.implicitNotFound
import org.scalaquery.SQueryException
import org.scalaquery.util.{ValueLinearizer, ProductLinearizer, NaturalTransformation2}

/**
 * A type class that encodes the unpacking `Mixed => Unpacked` of a
 * `Query[Mixed]` to its result element type `Unpacked` and the packing to a
 * fully packed type `Packed`, i.e. a type where everything which is not a
 * transparent container is wrapped in a `Column[_]`.
 *
 * =Example:=
 * - Mixed: (Column[Int], Column[(Int, String)], (Int, Option[Double]))
 * - Unpacked: (Int, (Int, String), (Int, Option[Double]))
 * - Packed: (Column[Int], Column[(Int, String)], (Column[Int], Column[Option[Double]]))
 * - Linearized: (Int, Int, String, Int, Option[Double])
 */
@implicitNotFound(msg = "Don't know how to unpack ${r"${Mixed_}"} to ${r"${Unpacked_}"} and pack to ${r"${Packed_}"}")
abstract class Packing[-Mixed_, Unpacked_, Packed_] {
  type Mixed = Mixed_
  type Unpacked = Unpacked_
  type Packed = Packed_
  def pack(from: Mixed): Packed
  def packedPacking: Packing[Packed, Unpacked, Packed]
  def linearizer(from: Mixed): ValueLinearizer[_]

  /** Build a packed representation from the shape and the TypeMappers alone.
   * This method is not available for packings where Mixed and Unpacked are
   * different types. */
  def buildPacked(f: NaturalTransformation2[TypeMapper, ({ type L[X] = Unpacked => X })#L, Column]): Packed

  protected[this] def impurePacking =
    throw new SQueryException("Packing does not have the same Mixed and Unpacked type")
}

object Packing extends PackingLowPriority {
  @inline
  def unpackTable[T <: AbstractTable[_]]: Packing[T, Nothing, T] =
    tablePacking.asInstanceOf[Packing[T, Nothing, T]]

  @inline
  implicit def unpackColumn[T]: Packing[Column[T], T, Column[T]] =
    selfLinearizingPacking.asInstanceOf[Packing[Column[T], T, Column[T]]]

  val selfLinearizingPacking: Packing[ValueLinearizer[_], Any, ValueLinearizer[_]] = new IdentityPacking[ValueLinearizer[_], Any] {
    def linearizer(from: Mixed) = from
    def buildPacked(f: NaturalTransformation2[TypeMapper, ({ type L[X] = Unpacked => X })#L, Column]) = impurePacking
  }

  val tablePacking: Packing[AbstractTable[_], Any, AbstractTable[_]] = new IdentityPacking[AbstractTable[_], Any] {
    def linearizer(from: Mixed) = from.*
    def buildPacked(f: NaturalTransformation2[TypeMapper, ({ type L[X] = Unpacked => X })#L, Column]) = impurePacking
  }
}

abstract class IdentityPacking[Packed, Unpacked] extends Packing[Packed, Unpacked, Packed] {
  def pack(from: Mixed): Packed = from
  def packedPacking: Packing[Packed, Unpacked, Packed] = this
}

class PackingLowPriority extends PackingLowPriority2 {
  @inline
  implicit final def unpackColumnBase[T, C <: ColumnBase[_]](implicit ev: C <:< ColumnBase[T]): Packing[C, T, C] =
    Packing.selfLinearizingPacking.asInstanceOf[Packing[C, T, C]]

  implicit final def unpackPrimitive[T](implicit tm: TypeMapper[T]): Packing[T, T, Column[T]] = new Packing[T, T, Column[T]] {
    def pack(from: Mixed) = ConstColumn(from)
    def packedPacking: Packing[Packed, Unpacked, Packed] = unpackColumnBase[T, Column[T]]
    def linearizer(from: Mixed) = ConstColumn(from)
    def buildPacked(f: NaturalTransformation2[TypeMapper, ({ type L[X] = Unpacked => X })#L, Column]): Packed =
      f(tm, identity)
  }
}

class PackingLowPriority2 {
<#list 2..22 as i>
  @inline
  implicit final def unpackTuple${i}[<#list 1..i as j>M${j}<#if i != j>,</#if></#list>, <#list 1..i as j>U${j}<#if i != j>,</#if></#list>, <#list 1..i as j>P${j}<#if i != j>,</#if></#list>](implicit <#list 1..i as j>u${j}: Packing[M${j}, U${j}, P${j}]<#if i != j>, </#if></#list>): Packing[(<#list 1..i as j>M${j}<#if i != j>,</#if></#list>), (<#list 1..i as j>U${j}<#if i != j>,</#if></#list>), (<#list 1..i as j>P${j}<#if i != j>,</#if></#list>)] =
    new TuplePacking(<#list 1..i as j>u${j}<#if i != j>,</#if></#list>)
</#list>
}

final class TuplePacking[M <: Product, U <: Product, P <: Product](ps: Packing[_, _, _]*) extends Packing[M, U, P] {
  def pack(from: Mixed) =
    buildTuple(ps.iterator.zip(from.productIterator).map{case (p, f) => p.pack(f.asInstanceOf[p.Mixed])}.toIndexedSeq).asInstanceOf[Packed]
  def packedPacking: Packing[Packed, Unpacked, Packed] =
    new TuplePacking(ps.map(_.packedPacking): _*)
  def linearizer(from: Mixed) =
    new ProductLinearizer(ps.iterator.zip(from.productIterator).map{case (p, f) => p.linearizer(f.asInstanceOf[p.Mixed])}.toIndexedSeq)
  def buildPacked(f: NaturalTransformation2[TypeMapper, ({ type L[X] = Unpacked => X })#L, Column]): Packed =
    buildTuple(ps.iterator.zipWithIndex.map{ case (p, i) => p.buildPacked(productTf(i, f)) }.toIndexedSeq).asInstanceOf[Packed]

  private[this] def productTf[Unpacked <: Product, U](idx: Int,
      f: NaturalTransformation2[TypeMapper, ({ type L[X] = Unpacked => X })#L, Column]):
      NaturalTransformation2[TypeMapper, ({ type L[X] = U => X })#L, Column] =
    new NaturalTransformation2[TypeMapper, ({ type L[X] = U => X })#L, Column] {
      def apply[T](p1: TypeMapper[T], p2: (U => T)) = f.apply[T](p1, (u => p2(u.productElement(idx).asInstanceOf[U])))
    }

  private[this] def buildTuple(s: IndexedSeq[Any]): Product = s.length match {
<#list 2..22 as i>
    case ${i} => (<#list 1..i as j>s(${j-1})<#if i != j>, </#if></#list>)
</#list>
  }
}

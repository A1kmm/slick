package org.scalaquery.ql

import scala.annotation.implicitNotFound
import org.scalaquery.SQueryException
import org.scalaquery.util.{Node, ValueLinearizer, ProductLinearizer, UnitLinearizer, WithOp}

/**
 * A type class that encodes the unpacking `From => To` of a `Query[From]` to
 * its result element type `To`. At run-time, it contains the mapping to the
 * TypeMappers of the linearized type of the query.
 *
 * =Example:=
 * - Packed type: (Column[Int], Column[(Int, String)], Option[Double])
 * - Unpacked type: (Int, (Int, String), Option[Double])
 * - Linearized type: (Int, Int, String, Option[Double])
 */
@implicitNotFound(msg = "Don't know how to unpack ${r"${From}"} to ${r"${To}"}")
sealed trait =>> [-From, +To] {
  type FromT = From
  type ToT = To
  def reify(from: From): Node = Node(from)
  def linearizer(from: From): ValueLinearizer[_]
  def mapOp(x: From, f: Node => Node): Any // really returns x.type
}

object =>> extends LowPriority_=>> {
  val unpackValueLinearizer = new =>> [ValueLinearizer[_] with WithOp, Nothing] {
    def linearizer(from: FromT): ValueLinearizer[_] = from
    def mapOp(from: FromT, f: Node => Node) = from.mapOp(f)
  }

  implicit def unpackJoin[T1 <: AbstractTable[_], T2 <: AbstractTable[_]]: Join[T1, T2] =>> (T1, T2) = new =>> [Join[T1, T2], (T1, T2)] {
    def linearizer(from: FromT) = from.left
    def mapOp(from: FromT, f: Node => Node) = from.mapOp(f)
  }

<#list 2..22 as i>
  implicit def unpackProjection${i}[<#list 1..i as j>T${j}<#if i != j>,</#if></#list>]: Projection${i}[<#list 1..i as j>T${j}<#if i != j>,</#if></#list>] =>> (<#list 1..i as j>T${j}<#if i != j>,</#if></#list>) = unpackValueLinearizer
</#list>

  type CanUnpack[-T] = T =>> _

  val unpackUnit: Unit =>> Unit = new =>> [Unit, Unit] {
    override def reify(from: FromT) = throw new SQueryException("Cannot reify a packed Unit column")
    def linearizer(from: FromT) = UnitLinearizer
    def mapOp(from: FromT, f: Node => Node) = from
  }

  val unpackTableBase: TableBase[_] =>> Nothing = new =>> [TableBase[_], Nothing] {
    def linearizer(from: FromT): ValueLinearizer[_] = from match {
      case a: AbstractTable[_] => a.*
      case j: Join[_, _] => j.left.*
    }
    def mapOp(from: FromT, f: Node => Node) = from.mapOp(f)
  }
}

trait LowPriority_=>> {
  implicit final def unpackPrimitive[T](implicit tm: TypeMapper[T]): T =>> T = new =>> [T, T] {
    override def reify(from: FromT) = ConstColumn(from)
    def linearizer(from: FromT) = ConstColumn(from)
    def mapOp(from: FromT, f: Node => Node) = from
  }
  implicit final def unpackColumnBase[T]: ColumnBase[T] =>> T = new =>> [ColumnBase[T], T] {
    def linearizer(from: FromT) = from
    def mapOp(from: FromT, f: Node => Node) = from.mapOp(f)
  }

<#list 2..22 as i>
  implicit final def unpackTuple${i}[<#list 1..i as j>T${j}<#if i != j>,</#if></#list>, <#list 1..i as j>U${j}<#if i != j>,</#if></#list>](implicit <#list 1..i as j>u${j}: T${j} =>> U${j}<#if i != j>, </#if></#list>): (<#list 1..i as j>T${j}<#if i != j>,</#if></#list>) =>> (<#list 1..i as j>U${j}<#if i != j>,</#if></#list>) = new =>> [(<#list 1..i as j>T${j}<#if i != j>,</#if></#list>), (<#list 1..i as j>U${j}<#if i != j>,</#if></#list>)] {
    override def reify(from: FromT) =
      Node((<#list 1..i as j>u${j}.reify(from._${j})<#if i != j>, </#if></#list>))
    def linearizer(from: FromT) = {
      val sub = Vector(<#list 1..i as j>u${j}.linearizer(from._${j})<#if i != j>, </#if></#list>)
      new ProductLinearizer(sub)
    }
    def mapOp(from: FromT, f: Node => Node) =
      (<#list 1..i as j>u${j}.mapOp(from._${j}, f)<#if i != j>, </#if></#list>)
  }
</#list>
}

/**
 * A packed value together with its unpacking
 */
case class Unpackable[T, +U](value: T, unpack: T =>> U) {
  def endoMap(f: T => T): Unpackable[T, U] = new Unpackable(f(value), unpack)
  def reified = unpack.reify(value)
  def linearizer = unpack.linearizer(value)
  def mapOp(f: Node => Node) = unpack.mapOp(value, f).asInstanceOf[T]
}
